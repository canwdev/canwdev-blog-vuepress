(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{685:function(t,e,a){"use strict";a.r(e);var r=a(57),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"watch和计算属性有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch和计算属性有什么区别"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://github.com/haizlin/fe-interview/issues/264",target:"_blank",rel:"noopener noreferrer"}},[t._v("watch和计算属性有什么区别？"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("参考："),a("a",{attrs:{href:"https://juejin.im/post/5c9990d6f265da60ea146d21",target:"_blank",rel:"noopener noreferrer"}},[t._v("面试题： Vue中的 computed 和 watch的区别"),a("OutboundLink")],1)]),t._v(" "),a("ul",[a("li",[t._v("computed看上去是方法，但是实际上是计算属性，它会根据你所依赖的数据动态显示新的计算结果。计算结果会被缓存，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算")]),t._v(" "),a("li",[t._v("watcher 更像是一个 data 的数据监听回调，当依赖的 data 的数据变化，执行回调，在方法中会传入 newVal 和 oldVal。可以提供输入值无效，提供中间值 特场景。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。如果你需要在某个数据变化时做一些事情，使用watch。")])]),t._v(" "),a("p",[t._v("总结：")]),t._v(" "),a("ul",[a("li",[t._v("如果一个数据依赖其他数据，就可以把这个数据做成 computed")]),t._v(" "),a("li",[t._v("如果需要在某个数据变化时做一些事情，使用 watch 来观察并处理这个数据的变化")])])])}),[],!1,null,null,null);e.default=n.exports}}]);