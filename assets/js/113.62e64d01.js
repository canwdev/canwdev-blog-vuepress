(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{689:function(e,t,r){"use strict";r.r(t);var i=r(57),n=Object(i.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"nexttick有什么作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#nexttick有什么作用"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://github.com/haizlin/fe-interview/issues/268",target:"_blank",rel:"noopener noreferrer"}},[e._v("$nextTick有什么作用？"),r("OutboundLink")],1)]),e._v(" "),r("ul",[r("li",[e._v("将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 "),r("code",[e._v("Vue.nextTick")]),e._v(" 一样，不同的是回调的 "),r("code",[e._v("this")]),e._v(" 自动绑定到调用它的实例上。")])]),e._v(" "),r("blockquote",[r("p",[e._v("2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不是原生支持 Promise (IE：你们都看我干嘛)，你得自行 polyfill。")])]),e._v(" "),r("hr"),e._v(" "),r("p",[e._v("理解：等待上一个 DOM 更新循环结束之后执行回调，解决了一些情况下获取不到 DOM 的问题。")])])}),[],!1,null,null,null);t.default=n.exports}}]);